// Generated by CoffeeScript 1.6.3
var EngineIoClient, debug, v4;

debug = require('debug')('vertex-client:base');

v4 = require('node-uuid').v4;

if (typeof require.exists === 'function') {
  EngineIoClient = require('engine.io');
} else {
  EngineIoClient = require('engine.io-client');
}

module.exports.create = function(config) {
  var local, _base;
  if (config == null) {
    config = {};
  }
  if (config.connect != null) {
    (_base = config.connect).interval || (_base.interval = 1000);
  }
  return local = {
    title: config.title != null ? config.title : 'Untitled',
    uuid: config.uuid != null ? config.uuid : v4(),
    context: config.context != null ? config.context : {},
    secret: config.secret != null ? config.secret : '',
    peers: {},
    status: {
      value: 'pending',
      at: new Date
    },
    connect: function() {
      var socket;
      if (local.socket != null) {
        return local.reconnect();
      }
      debug('connecting to %s', config.connect.uri);
      local.socket = socket = new EngineIoClient.Socket(config.connect.uri);
      socket.on('error', function(err) {
        debug('error %s', config.connect.uri, err);
        if (local.status.value === 'pending') {
          return local.reconnect('connecting');
        }
      });
      socket.on('open', function() {
        debug('opened %s', config.connect.uri);
        local.status.value = 'connected';
        local.status.at = new Date;
        if (local.connecting != null) {
          clearInterval(local.connecting);
          delete local.connecting;
        }
        if (local.reconnecting != null) {
          clearInterval(local.reconnecting);
          delete local.reconnecting;
        }
        return socket.send(JSON.stringify({
          event: 'handshake',
          data: {
            title: local.title,
            uuid: local.uuid,
            context: local.context,
            secret: local.secret
          }
        }));
      });
      socket.on('close', function() {
        debug('closed %s', config.connect.uri);
        if (local.status.value === 'denied') {
          return;
        }
        return local.reconnect('reconnecting');
      });
      return socket.on('message', function(payload) {
        var message;
        message = JSON.parse(payload);
        if (typeof local[message.event] === 'function') {
          return local[message.event](message);
        }
        return debug('missing event handler for %s', [message.event]);
      });
    },
    deny: function() {
      local.status.value = 'denied';
      local.status.at = new Date;
      return debug('denied');
    },
    accept: function() {
      local.status.value = 'accepted';
      local.status.at = new Date;
      return debug('accepted');
    },
    peer: function(message) {
      debug('peer event %s from %s', message.action, message.title);
      if (message.action === 'depart') {
        delete local.peers[message.uuid];
      } else if (message.action === 'join') {
        return local.peers[message.uuid] = {
          title: message.title,
          context: message.context
        };
      } else if (message.action === 'resume') {
        return local.peers[message.uuid] = {
          title: message.title,
          context: message.context
        };
      }
    },
    connecting: void 0,
    reconnecting: void 0,
    reconnect: function(type) {
      var interval;
      if (!(type === 'connecting' || type === 'reconnecting')) {
        return;
      }
      if (local[type] != null) {
        return;
      }
      interval = config.connect.interval;
      if (interval < 1000) {
        interval = 1000;
      }
      return local[type] = setInterval((function() {
        debug('%s to %s', type, config.connect.uri);
        return local.socket.open();
      }), interval);
    }
  };
};
